        /**
         * @class CustomMultiSelect
         * @classdesc A reusable, accessible custom multi-select dropdown component.
         * It mimics a single select dropdown visually but supports multi-selection.
         * Includes search, select all/deselect all, keyboard navigation, and WAI-ARIA attributes.
         * Now also supports single-select mode and DataTables row integration.
         */
        class CustomMultiSelect {

            /**
             * Helper method to update aria-activedescendant and visual indicator.
             * This is used when focus is NOT directly on a list item (e.g., on search or select all).
             * @private
             * @param {jQuery|null} $optionToHighlight - The jQuery object of the option to highlight, or null to clear.
             */
            _updateActiveDescendant($optionToHighlight) {
                // Remove focused-option class from previously highlighted item
                if (this.$customOptionsList && this.$customOptionsList.length) {
                   this.$customOptionsList.find('.focused-option').removeClass('focused-option');
                }

                if ($optionToHighlight && $optionToHighlight.length) {
                    // Ensure the option has an ID for aria-activedescendant
                    if (!$optionToHighlight.attr('id')) {
                        $optionToHighlight.attr('id', `${this.containerId}_option_${$optionToHighlight.index()}`);
                    }
                    if (this.$customOptionsList && this.$customOptionsList.length) {
                       this.$customOptionsList.attr('aria-activedescendant', $optionToHighlight.attr('id'));
                       $optionToHighlight.addClass('focused-option'); // Add visual highlight
                        // Optional: Scroll the item into view if needed
                        // $optionToHighlight[0].scrollIntoView({ block: 'nearest' });
                    }
                } else if (this.$customOptionsList && this.$customOptionsList.length) { // Refactored: Combined else and nested if
                       this.$customOptionsList.attr('aria-activedescendant', '');
                }
            }

            /**
             * Generates the display text for the selected values based on mode and options.
             * Extracted from updateDisplay to reduce complexity.
             * @private
             * @param {Array<string>} selectedTexts - An array of the text content of selected options.
             * @returns {string} The formatted text to display.
             */
            _generateDisplayText(selectedTexts) {
                const selectedCount = selectedTexts.length;
                const maxDisplay = this.options.maxDisplaySize;
                let displayText = '';

                if (selectedCount === 0) {
                    displayText = this.placeholderText;
                } else if (this.options.singleSelect === true) {
                    // In single select, just show the one selected item's text
                    displayText = selectedTexts[0] || this.placeholderText;
                } else if (maxDisplay > 0 && selectedCount > maxDisplay) {
                    // Multi-select with truncation
                    displayText = selectedTexts.slice(0, maxDisplay).join(', ') + ` (+${selectedCount - maxDisplay})`;
                } else {
                    // Multi-select, show all selected items
                    displayText = selectedTexts.join(', ');
                }
                return displayText;
            }

            /**
             * Updates the text displayed in the selected values display button.
             * Handles truncation based on maxDisplaySize option in multi-select mode.
             * In single-select mode, displays the text of the single selected item.
             * @public
             */
            updateDisplay() {
                if (!this.$selectedTextSpan || this.$selectedTextSpan.length === 0 || !this.$displayButton || this.$displayButton.length === 0) {
                    console.warn(`[${this.containerId}] updateDisplay: Required elements missing.`);
                    return;
                }

                const selectedTexts = this.getSelectedTexts();
                const selectedCount = selectedTexts.length;

                const displayText = this._generateDisplayText(selectedTexts);

                this.$selectedTextSpan.text(displayText);

                // Update placeholder class
                if (selectedCount === 0) {
                    this.$displayButton.addClass('placeholder');
                } else {
                    this.$displayButton.removeClass('placeholder');
                }

                // Update aria-label for the display button for better accessibility
                if (selectedCount > 0) {
                    this.$displayButton.attr('aria-label', `Selected option${selectedCount > 1 ? 's' : ''}: ${selectedTexts.join(', ')}`);
                } else {
                    this.$displayButton.attr('aria-label', this.placeholderText || 'Select options');
                }
            }


           /**
            * Default options for the component.
            * @static
            * @returns {object} Default options.
            */
           static get DEFAULTS() {
               return {
                   enableSearch: true, // Whether to show and enable the search input.
                   maxDisplaySize: 0, // Maximum number of selected items to display before truncating (0 means no limit).
                   singleSelect: false // Whether the component should behave as a single-select dropdown.
               };
           }

           /**
            * Initializes a new instance of the CustomMultiSelect component.
            * @param {jQuery} $container - The jQuery object representing the main container element.
            * @param {object} [options={}] - Configuration options to override defaults.
            */
           constructor($container, options = {}) {

               /** @member {jQuery} $container - The main container element. */
               this.$container = $container;

               // --- Merge default options with user-provided options ---
               this.options = $.extend({}, CustomMultiSelect.DEFAULTS, options);

               // --- Explicitly read and set boolean data attributes after initial merge ---
               // This ensures data attributes take precedence and are correctly typed as booleans
               const dataSingleSelect = this.$container.data('singleSelect');
               if (typeof dataSingleSelect !== 'undefined') {
                   // Explicitly check for the string "true" or "false"
                   this.options.singleSelect = (String(dataSingleSelect).toLowerCase() === 'true');
               }

               const dataEnableSearch = this.$container.data('enableSearch');
                if (typeof dataEnableSearch !== 'undefined') {
                    // Explicitly check for the string "true" or "false"
                   this.options.enableSearch = (String(dataEnableSearch).toLowerCase() === 'true');
               }
               // --- End explicit data attribute handling ---


               // --- Element References ---
               /** @member {jQuery} $labelElement - The screen reader only label element. */
               this.$labelElement = this.$container.find('.sr-only').first();
               /** @member {jQuery} $displayButton - The button that displays selected values and opens the dropdown. */
               this.$displayButton = this.$container.find('.selected-values-display').first();
                /** @member {jQuery} $selectedTextSpan - The span inside the display button holding the selected text. */
               this.$selectedTextSpan = this.$displayButton.find('.selected-text').first();
               /** @member {jQuery} $dropdownContainer - The container holding the search, select all, and options list. */
               this.$dropdownContainer = this.$container.find('.select-dropdown-container').first();
               /** @member {jQuery} $selectAllDiv - The "Select All" button/div. */
               this.$selectAllDiv = this.$container.find('.select-all-options').first();
               /** @member {jQuery} $customOptionsList - The UL element containing the custom options (LI). */
               this.$customOptionsList = this.$container.find('.custom-options-list').first();
               /** @member {jQuery} $searchInput - The search input field. */
               this.$searchInput = this.$dropdownContainer.find('.search-input').first();
               /** @member {jQuery} $liveRegion - The ARIA live region for announcements. */
               this.$liveRegion = this.$container.find('.sr-only[aria-live]').first();

               /** @member {string} placeholderText - The initial placeholder text from the display button. */
               this.placeholderText = this.$selectedTextSpan && this.$selectedTextSpan.length ? this.$selectedTextSpan.text().trim() : 'Select options...';

               /** @member {boolean} isDisabled - Tracks the disabled state of the component. */
               this.isDisabled = false;

               /** @member {Array<string>} _lastSelectedValues - Stores the last selected values for change event detection. */
               this._lastSelectedValues = []; // Initialize before loading options

                /** @member {Array<object>} _initialOptionsData - Stores the initial options data loaded into the component. */
                this._initialOptionsData = [];

                // --- Store the original parent of the dropdown container for DataTables integration ---
                /** @member {jQuery} _originalDropdownParent - The original parent element of the dropdown container. */
                this._originalDropdownParent = this.$dropdownContainer.parent();
                console.log(`[${this.$container.attr('id') || 'No ID'}] Stored original dropdown parent:`, this._originalDropdownParent[0]);


               // --- Explicitly bind methods to the instance to ensure 'this' context ---
               // Binding methods here guarantees 'this' refers to the instance
               this.updateDisplay = this.updateDisplay.bind(this);
               this._updateActiveDescendant = this._updateActiveDescendant.bind(this);
               this.showSelect = this.showSelect.bind(this);
               this.hideSelect = this.hideSelect.bind(this);
               this.toggleSelectAll = this.toggleSelectAll.bind(this);
               this.enable = this.enable.bind(this);
               this.disable = this.disable.bind(this);
               this.getSelectedValues = this.getSelectedValues.bind(this);
               this.getSelectedTexts = this.getSelectedTexts.bind(this);
               this.setSelectedValues = this.setSelectedValues.bind(this);
               this.setSelectedTexts = this.setSelectedTexts.bind(this);
               this.loadSelectOptions = this.loadSelectOptions.bind(this);
               this._handleDisplayButtonClick = this._handleDisplayButtonClick.bind(this);
               this._handleDisplayButtonKeydown = this._handleDisplayButtonKeydown.bind(this);
               this._handleSearchInput = this._handleSearchInput.bind(this);
               this._handleSearchInputKeydown = this._handleSearchInputKeydown.bind(this);
               this._handleSelectAllKeydown = this._handleSelectAllKeydown.bind(this);
               this._handleOptionClick = this._handleOptionClick.bind(this);
               this._handleOptionKeydown = this._handleOptionKeydown.bind(this);
               this._handleOptionMouseOver = this._handleOptionMouseOver.bind(this);
               this._handleOptionMouseOut = this._handleOptionMouseOut.bind(this);
               this._handleDocumentClick = this._handleDocumentClick.bind(this);
               this._handleDocumentFocusIn = this._handleDocumentFocusIn.bind(this);
               this._moveFocus = this._moveFocus.bind(this);
               this._handleNavigationFromLastOption = this._handleNavigationFromLastOption.bind(this);
               this._handleNavigationFromFirstOption = this._handleNavigationFromFirstOption.bind(this);
               this._toggleOptionSelection = this._toggleOptionSelection.bind(this);
               this._areArraysEqual = this._areArraysEqual.bind(this);
               this._triggerChangeEvent = this._triggerChangeEvent.bind(this);
               this._unbindEvents = this._unbindEvents.bind(this);
               this.showComponent = this.showComponent.bind(this); // Bind new method
               this.hideComponent = this.hideComponent.bind(this); // Bind new method
               this.refresh = this.refresh.bind(this); // Bind new method
                this.destroy = this.destroy.bind(this); // Bind new destroy method


               // --- ID Handling ---
               this._ensureUniqueIds();

               // --- Accessibility Setup ---
               this._setupAccessibility();

               // --- Bind Event Listeners ---
               this._bindEvents();

               // --- Initialization ---
               this._initializeComponent();

           }

            /**
             * Ensures a jQuery element has an ID, generating one based on the container ID if needed.
             * @private
             * @param {jQuery} $element - The jQuery element to check.
             * @param {string} idSuffix - The suffix to use for the generated ID (e.g., '_list').
             */
            _ensureElementId($element, idSuffix) {
                if ($element && $element.length) {
                    if (!$element.attr('id')) {
                        $element.attr('id', `${this.containerId}${idSuffix}`);
                    }
                }
            }

           /**
            * Ensures the container and key internal elements have unique IDs, generating them if necessary.
            * Sets up ARIA attributes based on these IDs.
            * @private
            */
           _ensureUniqueIds() {
                // Ensure the container element has an ID
                if (!this.$container.attr('id')) {
                    const generatedId = `customMultiSelect_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
                    this.$container.attr('id', generatedId);
                }
                /** @member {string} containerId - The unique ID of the container element. */
                this.containerId = this.$container.attr('id');

                // Ensure IDs for internal elements using the helper
                this._ensureElementId(this.$customOptionsList, '_list');
                this._ensureElementId(this.$labelElement, '_label');
                this._ensureElementId(this.$displayButton, '_display');
                this._ensureElementId(this.$searchInput, '_search');
           }

           /**
            * Sets up accessibility attributes for the listbox element.
            * @private
            */
           _setupListboxAccessibility() {
               if (this.$labelElement && this.$labelElement.length && this.$customOptionsList && this.$customOptionsList.length) {
                   this.$labelElement.text(this.placeholderText || 'Multi-select options');
                   this.$customOptionsList.attr('aria-labelledby', this.$labelElement.attr('id'));
                   this.$customOptionsList.attr('role', 'listbox');
                   this.$customOptionsList.attr('aria-multiselectable', this.options.singleSelect === true ? 'false' : 'true');
                   this.$customOptionsList.attr('aria-activedescendant', '');
               } else {
                    console.warn(`[${this.containerId}] Cannot set accessibility attributes on listbox: SR-only label or listbox element missing.`);
               }
           }

           /**
            * Sets up accessibility attributes for the display button.
            * @private
            */
           _setupDisplayButtonAccessibility() {
               if (this.$displayButton && this.$displayButton.length && this.$customOptionsList && this.$customOptionsList.length) {
                   this.$displayButton.attr('aria-haspopup', 'listbox');
                   this.$displayButton.attr('aria-expanded', 'false');
                   this.$displayButton.attr('aria-controls', this.$customOptionsList.attr('id'));

                   if (this.$labelElement && this.$labelElement.length && this.$displayButton.attr('id')) {
                        this.$displayButton.attr('aria-labelledby', `${this.$labelElement.attr('id')} ${this.$displayButton.attr('id')}`);
                   } else if (this.$displayButton.attr('id')) {
                        this.$displayButton.attr('aria-labelledby', this.$displayButton.attr('id'));
                   } else {
                        this.$displayButton.attr('aria-label', this.placeholderText || 'Select options');
                   }
               } else {
                    console.warn(`[${this.containerId}] Cannot set accessibility attributes on display button: Button, listbox, or SR label missing.`);
               }
           }

           /**
            * Sets up accessibility attributes for the Select All button.
            * @private
            */
           _setupSelectAllAccessibility() {
               if (this.$selectAllDiv && this.$selectAllDiv.length) {
                    this.$selectAllDiv.attr('tabindex', this.options.singleSelect === true ? '-1' : '0');
                    this.$selectAllDiv.attr('aria-disabled', this.options.singleSelect === true ? 'true' : 'false');
                    this.$selectAllDiv.attr('role', 'button');
                    this.$selectAllDiv.attr('aria-label', 'Select or Deselect All Options');
               } else {
                    console.warn(`[${this.containerId}] Select All element missing.`);
               }
           }

           /**
            * Sets up accessibility attributes for the search input.
            * @private
            */
           _setupSearchInputAccessibility() {
                if (this.$searchInput && this.$searchInput.length && this.$customOptionsList && this.$customOptionsList.length) {
                    this.$searchInput.attr('role', 'searchbox');
                    this.$searchInput.attr('aria-label', 'Search options');
                    this.$searchInput.attr('autocomplete', 'off');
                    this.$searchInput.attr('aria-controls', this.$customOptionsList.attr('id'));
                } else {
                    console.warn(`[${this.containerId}] Search input or listbox element missing for search accessibility.`);
                }
           }


           /**
            * Sets up initial WAI-ARIA attributes for accessibility.
            * Adjusts aria-multiselectable based on singleSelect option.
            * @private
            */
           _setupAccessibility() {
               this._setupListboxAccessibility();
               this._setupDisplayButtonAccessibility();
               this._setupSelectAllAccessibility();
               this._setupSearchInputAccessibility();
           }

           /**
            * Performs initial setup like showing/hiding search and select all, and updating the display.
            * @private
            */
           _initializeComponent() {
                // Conditionally show/hide search input based on options (use boolean value)
                if (this.$searchInput && this.$searchInput.length) {
                    if (this.options.enableSearch === true) { // Explicit boolean check
                        this.$searchInput.show();
                    } else {
                        this.$searchInput.hide();
                    }
                } else {
                    console.warn(`[${this.containerId}] Search input element missing.`);
                }


                // Conditionally show/hide Select All button based on singleSelect option (use boolean value)
                if (this.options.singleSelect === false && this.$selectAllDiv && this.$selectAllDiv.length) { // Explicit boolean check
                    this.$selectAllDiv.show();
                } else if (this.$selectAllDiv && this.$selectAllDiv.length) {
                    this.$selectAllDiv.hide();
                } else {
                    console.warn(`[${this.containerId}] Select All element missing.`);
                }


                // Update the display based on initial state (if options are in HTML)
                this.updateDisplay();
                // Initialize last selected values after initial display update
                this._lastSelectedValues = this.getSelectedValues();

                // If options are already in HTML, store them as initial data
                const initialHtmlOptions = [];
                if (this.$customOptionsList && this.$customOptionsList.length) {
                    this.$customOptionsList.find('li').each(function() {
                        const $item = $(this);
                        initialHtmlOptions.push({
                            value: $item.attr('data-value'),
                            text: $item.text().replace(/\s*笨能s*$/, '').trim(), // Clean up text
                            selected: $item.hasClass('selected-option')
                        });
                    });
                }
                this._initialOptionsData = initialHtmlOptions;
           }

            /**
             * Binds events for the display button.
             * @private
             * @param {string} eventNamespace - The event namespace for this instance.
             */
            _bindDisplayButtonEvents(eventNamespace) {
                if (this.$displayButton && this.$displayButton.length) {
                    this.$displayButton.on(`click${eventNamespace}`, this._handleDisplayButtonClick);
                    this.$displayButton.on(`keydown${eventNamespace}`, this._handleDisplayButtonKeydown);
                } else {
                    console.warn(`[${this.containerId}] Display button element missing, cannot bind events.`);
                }
            }

            /**
             * Binds events for the search input if enabled.
             * @private
             * @param {string} eventNamespace - The event namespace for this instance.
             */
            _bindSearchInputEvents(eventNamespace) {
                if (this.options.enableSearch === true && this.$searchInput && this.$searchInput.length) {
                    this.$searchInput.on(`input${eventNamespace}`, this._handleSearchInput);
                    this.$searchInput.on(`keydown${eventNamespace}`, this._handleSearchInputKeydown);
                    this.$searchInput.on(`change${eventNamespace}`, (event) => event.stopPropagation()); // Prevent native change event
                } else if (this.$searchInput && this.$searchInput.length) {
                    this.$searchInput.off(eventNamespace); // Ensure events are off if search is disabled
                } else {
                    console.warn(`[${this.containerId}] Search input element missing, cannot bind events.`);
                }
            }

            /**
             * Binds events for the Select All button if not in single-select mode.
             * @private
             * @param {string} eventNamespace - The event namespace for this instance.
             */
            _bindSelectAllEvents(eventNamespace) {
                if (this.options.singleSelect === false && this.$selectAllDiv && this.$selectAllDiv.length) {
                    this.$selectAllDiv.on(`click${eventNamespace}`, this.toggleSelectAll);
                    this.$selectAllDiv.on(`keydown${eventNamespace}`, this._handleSelectAllKeydown);
                } else if (this.$selectAllDiv && this.$selectAllDiv.length) {
                    this.$selectAllDiv.off(eventNamespace); // Ensure events are off if in single select or disabled
                } else {
                    console.warn(`[${this.containerId}] Select All element missing.`);
                }
            }

            /**
             * Binds events for the custom options list using delegation.
             * @private
             * @param {string} eventNamespace - The event namespace for this instance.
             */
            _bindOptionsListEvents(eventNamespace) {
                 if (this.$customOptionsList && this.$customOptionsList.length) {
                    this.$customOptionsList
                        .on(`click${eventNamespace}`, 'li', this._handleOptionClick)
                        .on(`keydown${eventNamespace}`, 'li', this._handleOptionKeydown)
                         .on(`mouseover${eventNamespace}`, 'li', this._handleOptionMouseOver)
                         .on(`mouseout${eventNamespace}`, 'li', this._handleOptionMouseOut);
                 } else {
                     console.warn(`[${this.containerId}] Custom options list element missing, cannot bind events.`);
                 }
            }

            /**
             * Binds global document events for hiding the dropdown.
             * @private
             * @param {string} eventNamespace - The event namespace for this instance.
             */
            _bindDocumentEvents(eventNamespace) {
                $(document).on(`click${eventNamespace}`, this._handleDocumentClick);
                $(document).on(`focusin${eventNamespace}`, this._handleDocumentFocusIn);
            }


           /**
            * Binds all necessary event listeners to the component elements.
            * Uses event delegation where appropriate.
            * @private
            */
           _bindEvents() {
               // Ensure events are unbound before binding to prevent duplicates
               this._unbindEvents();

               // Use a single event namespace for easier unbinding
               const eventNamespace = `.customMultiSelect_${this.containerId}`;

               this._bindDisplayButtonEvents(eventNamespace);
               this._bindSearchInputEvents(eventNamespace);
               this._bindSelectAllEvents(eventNamespace);
               this._bindOptionsListEvents(eventNamespace);
               this._bindDocumentEvents(eventNamespace);
           }

           /**
            * Unbinds all event listeners associated with this component instance.
            * @private
            */
           _unbindEvents() {
                const eventNamespace = `.customMultiSelect_${this.containerId}`;

                if (this.$displayButton && this.$displayButton.length) this.$displayButton.off(eventNamespace);
                if (this.$searchInput && this.$searchInput.length) this.$searchInput.off(eventNamespace);
                if (this.$selectAllDiv && this.$selectAllDiv.length) this.$selectAllDiv.off(eventNamespace);
                if (this.$customOptionsList && this.$customOptionsList.length) this.$customOptionsList.off(eventNamespace, 'li');
                $(document).off(eventNamespace);

           }


           // --- Event Handlers ---

           /**
            * Handles click event on the display button. Toggles dropdown visibility.
            * @private
            */
           _handleDisplayButtonClick() {
                if (this.isDisabled) return;
                if (this.$dropdownContainer && this.$dropdownContainer.length) {
                    if (this.$dropdownContainer.is(':visible')) {
                        this.hideSelect();
                    } else {
                        this.showSelect();
                    }
                } else {
                    console.warn(`[${this.containerId}] Display button click handler: Dropdown container missing.`);
                }
           }

           /**
            * Handles keydown event on the display button. Opens dropdown on Enter, Space, ArrowDown.
            * @private
            * @param {KeyboardEvent} event - The keydown event object.
            */
           _handleDisplayButtonKeydown(event) {
                if (this.isDisabled) return;
                if (event.key === 'Enter' || event.key === ' ' || event.key === 'ArrowDown') {
                    event.preventDefault();
                    this.showSelect();
                } else if (event.key === 'ArrowUp') {
                    // Allow ArrowUp to open the select if closed
                    if (this.$dropdownContainer && this.$dropdownContainer.length && !this.$dropdownContainer.is(':visible')) {
                        event.preventDefault();
                        this.showSelect();
                    }
                }
           }

           /**
            * Filters the options list based on the search input value.
            * Extracted from _handleSearchInput for clarity.
            * @private
            * @param {string} searchTerm - The text to filter by.
            * @returns {number} The number of visible options after filtering.
            */
           _filterOptions(searchTerm) {
                if (!this.$customOptionsList || this.$customOptionsList.length === 0) {
                    return 0;
                }

                const $optionItems = this.$customOptionsList.find('li');
                let visibleCount = 0;

                $optionItems.each(function() {
                    const $item = $(this);
                    // Cache the text content to avoid re-reading the DOM in each iteration
                    const itemText = $item.data('text') || $item.text().toLowerCase();
                    if (!$item.data('text')) {
                        $item.data('text', itemText); // Store cached text
                    }


                    if (itemText.includes(searchTerm)) {
                        $item.show();
                        visibleCount++;
                    } else {
                        $item.hide();
                    }
                });
                return visibleCount;
           }

           /**
            * Updates the ARIA live region with the search results count.
            * Extracted from _handleSearchInput.
            * @private
            * @param {string} searchTerm - The current search term.
            * @param {number} visibleCount - The number of visible options.
            */
           _updateSearchResultsLiveRegion(searchTerm, visibleCount) {
                if (this.$liveRegion && this.$liveRegion.length) {
                    if (searchTerm === '') {
                        this.$liveRegion.text('');
                    } else if (visibleCount === 0) {
                        this.$liveRegion.text('No results found.');
                    } else {
                        this.$liveRegion.text(`${visibleCount} results found.`);
                    }
                }
           }


           /**
            * Handles input event on the search input. Filters the options list.
            * @private
            */
           _handleSearchInput() {
                if (this.isDisabled) return;
                if (!this.$searchInput || this.$searchInput.length === 0 || !this.$customOptionsList || this.$customOptionsList.length === 0) {
                    console.warn(`[${this.containerId}] Search input handler: Required elements missing.`);
                    return;
                }

                const searchTerm = this.$searchInput.val().toLowerCase();

                const $optionItems = this.$customOptionsList.find('li');
                let visibleCount = 0;

                // Optimized filtering loop
                $optionItems.each(function() {
                    const $item = $(this);
                    // Cache the text content to avoid re-reading the DOM in each iteration
                    const itemText = $item.data('text') || $item.text().toLowerCase();
                    if (!$item.data('text')) {
                        $item.data('text', itemText); // Store cached text
                    }


                    if (itemText.includes(searchTerm)) {
                        $item.show();
                        visibleCount++;
                    } else {
                        $item.hide();
                    }
                });

                // Update live region with search results count
                if (this.$liveRegion && this.$liveRegion.length) {
                    if (searchTerm === '') {
                        this.$liveRegion.text('');
                    } else if (visibleCount === 0) {
                        this.$liveRegion.text('No results found.');
                    } else {
                        this.$liveRegion.text(`${visibleCount} results found.`);
                    }
                }

                // After filtering, if search has focus, highlight the first visible enabled option
                if (this.$searchInput.is(':focus')) {
                    const $firstVisibleEnabledOption = this.$customOptionsList.find('li:visible:not(.disabled-option)').first();
                    this._updateActiveDescendant($firstVisibleEnabledOption);
                }
           }

           /**
            * Handles keydown event on the search input. Manages keyboard navigation from search.
            * @private
            * @param {KeyboardEvent} event - The keydown event object.
            */
           _handleSearchInputKeydown(event) {
                if (this.isDisabled) return;
                if (!this.$customOptionsList || this.$customOptionsList.length === 0 || !this.$searchInput || this.$searchInput.length === 0) {
                    console.warn(`[${this.containerId}] Search input keydown handler: Required elements missing.`);
                    return;
                }

                switch (event.key) {
                    case 'ArrowDown':
                        event.preventDefault();
                        // In single select, ArrowDown from search goes directly to the first option.
                        // In multi-select, it goes to Select All or the first option.
                        if (this.options.singleSelect === false && this.$selectAllDiv && this.$selectAllDiv.length && this.$selectAllDiv.is(':visible') && this.$selectAllDiv.attr('aria-disabled') !== 'true') { // Explicit boolean check
                            this.$selectAllDiv.focus();
                            this._updateActiveDescendant(null);
                        } else {
                            const $firstVisibleEnabledOption = this.$customOptionsList.find('li:visible:not(.disabled-option)').first();
                             if ($firstVisibleEnabledOption.length) {
                                 this._moveFocus(this.$searchInput, $firstVisibleEnabledOption); // Use moveFocus helper
                                 this._updateActiveDescendant(null); // Clear active descendant as focus is now on the item
                             }
                        }
                        break;
                    case 'Escape':
                        event.preventDefault();
                        this.hideSelect();
                        if (this.$displayButton && this.$displayButton.length) this.$displayButton.focus();
                        break;
                }
           }

           /**
            * Handles keydown event on the Select All button. Manages keyboard navigation from Select All.
            * Only active in multi-select mode.
            * @private
            * @param {KeyboardEvent} event - The keydown event object.
            */
           _handleSelectAllKeydown(event) {
                if (this.isDisabled || this.options.singleSelect === true) return; // Explicit boolean check
                if (!this.$selectAllDiv || this.$selectAllDiv.length === 0 || !this.$customOptionsList || this.$customOptionsList.length === 0) {
                    console.warn(`[${this.containerId}] Select All keydown handler: Required elements missing.`);
                    return;
                }

                switch (event.key) {
                    case 'Enter':
                    case ' ':
                        event.preventDefault();
                        this.toggleSelectAll();
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        // Focus the first *visible* and *enabled* option
                        const $firstVisibleEnabledOption = this.$customOptionsList.find('li:visible:not(.disabled-option)').first();
                        if ($firstVisibleEnabledOption.length) {
                            this._moveFocus(this.$selectAllDiv, $firstVisibleEnabledOption); // Use moveFocus helper
                            this._updateActiveDescendant(null); // Clear active descendant as focus is now on the item
                        }
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        // Move focus to the search input if enabled and visible (use boolean value)
                        if (this.options.enableSearch === true && this.$searchInput && this.$searchInput.length && this.$searchInput.is(':visible') && !this.$searchInput.prop('disabled')) { // Explicit boolean check
                            this._moveFocus(this.$selectAllDiv, this.$searchInput); // Use moveFocus helper
                            this._updateActiveDescendant(null); // Clear active descendant as focus is now on the search input
                        }
                        break;
                    case 'Escape':
                        event.preventDefault();
                        this.hideSelect();
                        if (this.$displayButton && this.$displayButton.length) this.$displayButton.focus();
                        break;
                }
           }

           /**
            * Handles click event on a list item (option). Toggles selection in multi-select,
            * selects and closes in single-select.
            * @private
            * @param {MouseEvent} event - The click event object.
            */
           _handleOptionClick(event) {
                if (this.isDisabled) return;
                const $clickedItem = $(event.currentTarget);

                if ($clickedItem.hasClass('disabled-option')) {
                    return;
                }

                if (this.options.singleSelect === true) { // Explicit boolean check
                     // Single select mode: Deselect all others, select this one, and close
                     this.$customOptionsList.find('li.selected-option').removeClass('selected-option').attr('aria-selected', 'false');
                     $clickedItem.addClass('selected-option').attr('aria-selected', 'true');
                     this.updateDisplay();
                     this._triggerChangeEvent();
                     this.hideSelect(); // Close the dropdown after selection in single select
                     if (this.$displayButton && this.$displayButton.length) this.$displayButton.focus(); // Return focus to display button
                } else {
                     // Multi-select mode: Toggle selection
                     this._toggleOptionSelection($clickedItem);
                     this.updateDisplay();
                     this._triggerChangeEvent();

                     // Update Select All button text based on current selection
                     const $optionItems = this._getSelectAllTargetOptions(); // Gets all enabled options
                     const totalOptions = $optionItems.length;
                     const selectedOptionsCount = $optionItems.filter('.selected-option').length;
                     const allSelected = totalOptions > 0 && selectedOptionsCount === totalOptions; // Ensure totalOptions is not zero
                     this._updateSelectAllButton(allSelected);

                     // Keep focus on the clicked item in multi-select
                     $clickedItem.focus();
                     this._updateActiveDescendant(null); // Clear active descendant as focus is on the item
                }
           }

           /**
            * Handles keydown event on a list item (option). Manages keyboard navigation and selection.
            * Behavior differs slightly based on singleSelect mode.
            * @private
            * @param {KeyboardEvent} event - The keydown event object.
            */
           _handleOptionKeydown(event) {
                if (this.isDisabled) return;
                const $currentItem = $(event.currentTarget);
                if ($currentItem.hasClass('disabled-option')) {
                    return;
                }

                if (!this.$customOptionsList || this.$customOptionsList.length === 0) {
                     console.warn(`[${this.containerId}] List item keydown handler: Options list missing.`);
                     return;
                }

                const $optionItems = this.$customOptionsList.find('li:visible:not(.disabled-option)'); // Only consider *visible* and *enabled* options

                // ** Add check for $optionItems validity before proceeding **
                if (!$optionItems || $optionItems.length === 0) {
                    return; // Exit if no options are found after filtering
                }


                const currentIndex = $optionItems.index($currentItem);


                switch (event.key) {
                    case 'ArrowDown':
                        event.preventDefault();
                        // Add check to ensure there is a next index
                        if (currentIndex < $optionItems.length - 1) {
                            const $nextItem = $optionItems.eq(currentIndex + 1);
                            // ** Add check for $nextItem validity before accessing length or focusing **
                            if ($nextItem && $nextItem.length) { // This is the crucial check
                                this._moveFocus($currentItem, $nextItem); // Use moveFocus helper
                                 this._updateActiveDescendant(null); // Clear active descendant as focus is now on the item
                            }
                        } else {
                              // If at the last item, move focus to the search input if enabled, or Select All if available, or loop to the first item
                             this._handleNavigationFromLastOption($currentItem); // Use helper
                        }
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        // Add check to ensure there is a previous index or an element above
                        if (currentIndex > 0) {
                            // Move focus to the previous visible enabled option
                            const $prevItem = $optionItems.eq(currentIndex - 1);
                            // ** Add check for $prevItem validity before accessing length or focusing **
                            if ($prevItem && $prevItem.length) { // This is the crucial check
                                 this._moveFocus($currentItem, $prevItem); // Use helper
                                 this._updateActiveDescendant(null); // Clear active descendant as focus is on the item
                            }
                        } else {
                            // If at the first item, move focus to Select All or search input
                            this._handleNavigationFromFirstOption($currentItem); // Use helper
                        }
                        break;
                    case ' ':
                    case 'Enter':
                        event.preventDefault();
                        // Trigger click to toggle selection (multi) or select and close (single)
                        $currentItem.trigger('click');
                        break;
                    case 'Escape':
                        event.preventDefault();
                        this.hideSelect(); // hideSelect has internal checks now
                         // Add check before focusing
                        if (this.$displayButton && this.$displayButton.length) { // Added length check
                           this.$displayButton.focus();
                        }
                        break;
                }
           }

            /**
             * Handles mouseover event on a list item. Updates aria-activedescendant for screen readers.
             * @private
             * @param {MouseEvent} event - The mouseover event object.
             */
            _handleOptionMouseOver(event) {
                if (this.isDisabled) return;
                const $hoveredItem = $(event.currentTarget);
                if (!$hoveredItem.hasClass('disabled-option')) {
                     // If focus is not currently on a list item, update aria-activedescendant on mouseover
                    if (this.$customOptionsList && this.$customOptionsList.length && !this.$customOptionsList.find(':focus').length) { // Added length check
                         this._updateActiveDescendant($hoveredItem);
                    }
                }
            }

            /**
             * Handles mouseout event on a list item. Clears aria-activedescendant if focus leaves the list.
             * @private
             * @param {MouseEvent} event - The mouseout event object.
             */
            _handleOptionMouseOut(event) {
                if (this.isDisabled) return;
                // Only clear if the focus is not within the listbox, search, or select all
                if (this.$customOptionsList && this.$customOptionsList.length &&
                    !this.$customOptionsList.find(':focus').length &&
                    !(this.options.enableSearch === true && this.$searchInput && this.$searchInput.length && this.$searchInput.is(':focus')) && // Explicit boolean check
                    !(this.options.singleSelect === false && this.$selectAllDiv && this.$selectAllDiv.length && this.$selectAllDiv.attr('aria-disabled') !== 'true')) { // Explicit boolean check
                     this._updateActiveDescendant(null);
                }
           }


           /**
            * Handles click events on the document to close the dropdown if the click is outside.
            * @private
            * @param {MouseEvent} event - The click event object.
            */
           _handleDocumentClick(event) {
                if (this.isDisabled) return;
                // Check if the click occurred outside this specific container AND the dropdown is currently visible
                if (this.$container && this.$container.length && this.$dropdownContainer && this.$dropdownContainer.length &&
                    !$.contains(this.$container[0], event.target) && this.$dropdownContainer.is(':visible')) {
                    this.hideSelect();
                }
           }

           /**
            * Handles focusin events on the document to close the dropdown if focus moves outside.
            * Uses a small delay to ensure focus has settled.
            * @private
            * @param {FocusEvent} event - The focusin event object.
            */
           _handleDocumentFocusIn(event) {
                if (this.isDisabled) return;
                const containerElement = this.$container && this.$container.length ? this.$container[0] : null;

                if (containerElement && $.contains(document.documentElement, containerElement)) {
                     if (!$.contains(containerElement, event.target)) {
                          // Add a small delay to check focus state after blur/focus events complete
                          setTimeout(() => {
                               // Re-get the instance and element inside the timeout for robustness
                                const $containerInTimeout = $(`#${this.containerId}`); // Use this.containerId
                                const instanceInTimeout = $containerInTimeout.length ? $containerInTimeout.data('customMultiSelect') : null; // Get instance by ID
                                const elementInTimeout = $containerInTimeout.length ? $containerInTimeout[0] : null; // Get element by ID

                                // Check if the instance, element, and dropdown are still valid and visible,
                                // and if focus is still outside the container and the component is not disabled.
                                if (instanceInTimeout && elementInTimeout && $.contains(document.documentElement, elementInTimeout) && instanceInTimeout.$dropdownContainer && instanceInTimeout.$dropdownContainer.length && instanceInTimeout.$dropdownContainer.is(':visible') && !$.contains(instanceInTimeout.$container[0], document.activeElement) && !$.contains(instanceInTimeout.$dropdownContainer[0], document.activeElement) && !instanceInTimeout.isDisabled) {
                                    instanceInTimeout.hideSelect(); // hideSelect has internal checks now
                                } else {
                                    console.log(`[${this.containerId}] Focus moved back inside during delay, component is disabled, or instance/element is no longer valid.`);
                                }
                           }, 1);
                      }
                 } else {
                     // Container element is no longer in the DOM, no action needed.
                 }
           }


           // --- Helper Methods for Keyboard Navigation ---

           /**
            * Moves focus from one element to another and updates tabindex.
            * @private
            * @param {jQuery} $fromItem - The jQuery object of the element losing focus.
            * @param {jQuery} $toItem - The jQuery object of the element gaining focus.
            */
           _moveFocus($fromItem, $toItem) {
                // Ensure the element we are moving focus *from* is focusable via script
                if ($fromItem && $fromItem.length && ($fromItem.is('li') || $fromItem.is('input') || $fromItem.is('[role="button"]'))) {
                    $fromItem.attr('tabindex', '-1');
                }
                if ($toItem && $toItem.length) {
                    $toItem.attr('tabindex', '0');
                    $toItem.focus();
                }
           }

           /**
            * Handles keyboard navigation when the last option in the list has focus (ArrowDown).
            * Moves focus to the search input (if enabled) or Select All button (multi-select only).
            * @private
            * @param {jQuery} $currentItem - The jQuery object of the currently focused list item.
            */
           _handleNavigationFromLastOption($currentItem) {
                // Try to move focus to the search input if enabled and visible (use boolean value)
                if (this.options.enableSearch === true && this.$searchInput && this.$searchInput.length && this.$searchInput.is(':visible') && !this.$searchInput.prop('disabled')) { // Explicit boolean check
                    this._moveFocus($currentItem, this.$searchInput); // Use moveFocus helper
                    this._updateActiveDescendant(null); // Clear active descendant as focus is now on the search input
                }
                // If search is not available/enabled, try to move focus to Select All (multi-select only) (use boolean value)
                else if (this.options.singleSelect === false && this.$selectAllDiv && this.$selectAllDiv.length && this.$selectAllDiv.is(':visible') && this.$selectAllDiv.attr('aria-disabled') !== 'true') { // Explicit boolean check
                    this._moveFocus($currentItem, this.$selectAllDiv); // Use moveFocus helper
                    this._updateActiveDescendant(null); // Clear active descendant as focus is now on Select All
                }
                // If no element above, keep focus on the last item (or loop back if desired, but keeping focus is simpler)
                else if ($currentItem && $currentItem.length) { // Refactored: Combined else and nested if
                    $currentItem.attr('tabindex', '0'); // Restore tabindex if focus didn't move
                }
           }

           /**
            * Handles keyboard navigation when the first option in the list has focus (ArrowUp).
            * Moves focus to the Select All button (multi-select only) or search input.
            * @private
            * @param {jQuery} $currentItem - The jQuery object of the currently focused list item.
            */
           _handleNavigationFromFirstOption($currentItem) {
                // Try to move focus to Select All first (multi-select only) (use boolean value)
                if (this.options.singleSelect === false && this.$selectAllDiv && this.$selectAllDiv.length && this.$selectAllDiv.is(':visible') && this.$selectAllDiv.attr('aria-disabled') !== 'true') { // Explicit boolean check
                    this._moveFocus($currentItem, this.$selectAllDiv); // Use moveFocus helper
                    this._updateActiveDescendant(null); // Clear active descendant as focus is now on Select All
                }
                // If Select All is not available/enabled, try to move focus to the search input (if enabled) (use boolean value)
                else if (this.options.enableSearch === true && this.$searchInput && this.$searchInput.length && this.$searchInput.is(':visible') && !this.$searchInput.prop('disabled')) { // Explicit boolean check
                    this._moveFocus($currentItem, this.$searchInput); // Use moveFocus helper
                    this._updateActiveDescendant(null); // Clear active descendant as focus is now on the search input
                }
                // If no element above, keep focus on the first item
                else {
                    if ($currentItem && $currentItem.length) $currentItem.attr('tabindex', '0'); // Restore tabindex if focus didn't move
                }
           }


           /**
            * Toggles the selected state of a given option element.
            * Only used in multi-select mode.
            * @private
            * @param {jQuery} $optionItem - The jQuery object of the option to toggle.
            */
           _toggleOptionSelection($optionItem) {
                if (this.options.singleSelect === true) { // Explicit boolean check
                     // In single select, this method should not be called directly for toggling
                     console.warn(`[${this.containerId}] _toggleOptionSelection called in single-select mode. Use _handleOptionClick instead.`);
                     return;
                }
                if ($optionItem && $optionItem.length) {
                    $optionItem.toggleClass('selected-option');
                    const isSelected = $optionItem.hasClass('selected-option');
                    $optionItem.attr('aria-selected', isSelected ? 'true' : 'false');
                } else {
                     console.warn(`[${this.containerId}] _toggleOptionSelection: Invalid option item provided.`);
                }
           }


           /**
            * Helper method to check if two arrays are equal (order-independent).
            * Used to determine if the selection state has actually changed.
            * @private
            * @param {Array<any>} arr1 - The first array.
            * @param {Array<any>} arr2 - The second array.
            * @returns {boolean} True if the arrays contain the same elements, regardless of order.
            */
           _areArraysEqual(arr1, arr2) {
               if (!Array.isArray(arr1) || !Array.isArray(arr2)) {
                   return false;
               }
               if (arr1.length !== arr2.length) {
                   return false;
               }
               const sortedArr1 = [...arr1].sort();
               const sortedArr2 = [...arr2].sort();
               for (let i = 0; i < sortedArr1.length; i++) {
                   if (sortedArr1[i] !== sortedArr2[i]) {
                       return false;
                   }
               }
               return true;
           }

           /**
            * Triggers a custom 'change.customMultiSelect' event on the container element
            * if the selection state has actually changed since the last update.
            * @private
            */
           _triggerChangeEvent() {
                if (this.$container && this.$container.length) {
                   const currentSelectedValues = this.getSelectedValues();
                   const currentSelectedTexts = this.getSelectedTexts();

                   // Check if the selection state has actually changed
                   if (!this._areArraysEqual(currentSelectedValues, this._lastSelectedValues)) {
                        // Update last recorded values *before* triggering the event
                        this._lastSelectedValues = [...currentSelectedValues];
                        this.$container.trigger('change.customMultiSelect', [currentSelectedValues, currentSelectedTexts]);
                   }
                } else {
                    console.warn(`[${this.containerId}] _triggerChangeEvent: Container element missing, cannot trigger event.`);
                }
           }

            /**
             * Performs common cleanup and update tasks after selection changes.
             * @private
             */
            _performPostSelectionCleanup() {
                // Clear search and show all options after setting values
                if (this.$searchInput && this.$searchInput.length) this.$searchInput.val('');
                if (this.$customOptionsList && this.$customOptionsList.length) this.$customOptionsList.find('li').show();
                this._updateActiveDescendant(null); // Clear active descendant


                this.updateDisplay();
                this._triggerChangeEvent();

                // Update Select All button text based on current selection
                const $optionItems = this._getSelectAllTargetOptions();
                const totalOptions = $optionItems.length;
                const selectedOptionsCount = $optionItems.filter('.selected-option').length;
                const allSelected = totalOptions > 0 && selectedOptionsCount === totalOptions;
                this._updateSelectAllButton(allSelected);
            }

            /**
             * Updates the selection state of options based on a provided list of items (values or texts).
             * @private
             * @param {Array<string>} items - An array of values or texts to select.
             * @param {boolean} isValuesList - True if the items are values, false if they are texts.
             */
            _updateSelectionByList(items, isValuesList) {
                 if (!Array.isArray(items)) {
                     console.warn(`[${this.containerId}] _updateSelectionByList expects an array.`);
                     return;
                 }
                 if (!this.$customOptionsList || this.$customOptionsList.length === 0) {
                      console.warn(`[${this.containerId}] _updateSelectionByList: Options list missing.`);
                      return;
                 }

                 const self = this;

                 // Deselect all first
                 this.$customOptionsList.find('li.selected-option').each(function() {
                     self._setOptionSelectedState($(this), false);
                 });
                 console.log(`[${self.containerId}] Cleared current selections.`);

                 // Select the specified items
                 items.forEach(item => {
                     let $itemToSelect;
                     if (isValuesList) {
                         $itemToSelect = self.$customOptionsList.find(`li[data-value="${item}"]`);
                     } else {
                         // Find by text (case-insensitive, trimmed)
                         $itemToSelect = self.$customOptionsList.find('li').filter(function() {
                             const $li = $(this);
                             const itemText = $li.data('original-text') || $li.text().replace(/\s*笨能s*$/, '').trim();
                             if (!$li.data('original-text')) {
                                  $li.data('original-text', itemText);
                             }
                             return itemText === item;
                         }).first(); // Get the first match if multiple have same text
                     }


                     if ($itemToSelect.length) {
                         // In single select, ensure only the last item in the array is selected
                         if (self.options.singleSelect === true && item !== items[items.length - 1]) {
                             return; // Skip if not the last item in single select mode
                         }
                         self._setOptionSelectedState($itemToSelect, true);
                          console.log(`[${self.containerId}] Selected option with ${isValuesList ? 'value' : 'text'}: ${item}`);
                     } else {
                         console.warn(`[${self.containerId}] Option with ${isValuesList ? 'value' : 'text'} "${item}" not found.`);
                     }
                 });
            }


           // --- Public Methods (API) ---

           /**
            * Shows the dropdown list.
            * @public
            */
           showSelect() {
                if (this.isDisabled) {
                    return;
                }
                if (this.$displayButton && this.$displayButton.length) this.$displayButton.attr('aria-expanded', 'true');
                if (this.$dropdownContainer && this.$dropdownContainer.length) this.$dropdownContainer.show();

                // Focus management after showing the dropdown
                // If search is enabled, focus search (use boolean value)
                if (this.options.enableSearch === true && this.$searchInput && this.$searchInput.length && this.$searchInput.is(':visible') && !this.$searchInput.prop('disabled')) { // Explicit boolean check
                    this.$searchInput.focus();
                }
                // If single select, focus the selected option or first enabled option (use boolean value)
                else if (this.options.singleSelect === true && this.$customOptionsList && this.$customOptionsList.length) { // Explicit boolean check
                     const $selectedOption = this.$customOptionsList.find('li.selected-option:not(.disabled-option)').first();
                     const $firstEnabledOption = this.$customOptionsList.find('li:not(.disabled-option)').first();
                     let $optionToFocus = null;

                     if ($selectedOption.length) {
                         $optionToFocus = $selectedOption;
                     } else if ($firstEnabledOption.length) {
                         $optionToFocus = $firstEnabledOption;
                     }

                     if ($optionToFocus && $optionToFocus.length) {
                         $optionToFocus.attr('tabindex', '0');
                         $optionToFocus.focus();
                     }
                }
                // If multi-select and no search, focus Select All (use boolean value)
                else if (this.options.singleSelect === false && this.$selectAllDiv && this.$selectAllDiv.length && this.$selectAllDiv.attr('aria-disabled') !== 'true') { // Explicit boolean check
                   this.$selectAllDiv.focus();
                }
                // Fallback: focus the first visible enabled option in the list
                else if (this.$customOptionsList && this.$customOptionsList.length) {
                    const $firstOption = this.$customOptionsList.find('li:visible:not(.disabled-option)').first();
                    if ($firstOption.length) {
                        $firstOption.attr('tabindex', '0');
                        $firstOption.focus();
                    }
                }
           }

           /**
            * Hides the dropdown list.
            * @public
            */
           hideSelect() {
                if (this.$dropdownContainer && this.$dropdownContainer.length) this.$dropdownContainer.hide();
                if (this.$displayButton && this.$displayButton.length) this.$displayButton.attr('aria-expanded', 'false');

                this.updateDisplay(); // Update the display text

                // Clear search and show all options when hiding
                if (this.$searchInput && this.$searchInput.length) this.$searchInput.val('');
                if (this.$customOptionsList && this.$customOptionsList.length) this.$customOptionsList.find('li').show();

                // Ensure all list items have tabindex="-1" when the dropdown is hidden
                if (this.$customOptionsList && this.$customOptionsList.length) this.$customOptionsList.find('li').attr('tabindex', '-1');

                // Clear aria-activedescendant and any visual highlight
                this._updateActiveDescendant(null);

                // Clear live region text
                if (this.$liveRegion && this.$liveRegion.length) this.$liveRegion.text('');


                // Return focus to the display button if focus is still within the container
                if (this.$container && this.$container.length && this.$container.find(':focus').length > 0) {
                     if(this.$displayButton && this.$displayButton.length) {
                       this.$displayButton.focus();
                     }
                } else {
                     console.log(`[${this.containerId}] Focus was already outside the container or container is invalid.`);
                }
           }

            /**
             * Gets the relevant option items for toggleSelectAll (visible and enabled).
             * Extracted from toggleSelectAll.
             * @private
             * @returns {jQuery} A jQuery collection of relevant option items.
             */
            _getSelectAllTargetOptions() {
                 if (!this.$customOptionsList || this.$customOptionsList.length === 0) {
                      return $(); // Return empty jQuery object if list is missing
                 }
                 // Always operate on all enabled options, regardless of search filter
                 return this.$customOptionsList.find('li:not(.disabled-option)');
            }

            /**
             * Updates the text and class of the Select All button.
             * Extracted from toggleSelectAll.
             * @private
             * @param {boolean} allSelected - True if all relevant options are selected.
             */
            _updateSelectAllButton(allSelected) {
                 console.log(`[${this.containerId}] _updateSelectAllButton called. All selected: ${allSelected}`); // Added log
                 if (this.$selectAllDiv && this.$selectAllDiv.length) {
                     this.$selectAllDiv.text(allSelected ? 'Deselect All' : 'Select All'); // Corrected text logic
                     if (allSelected) {
                         this.$selectAllDiv.addClass("selected");
                     } else {
                         this.$selectAllDiv.removeClass("selected");
                     }
                 }
            }


           /**
            * Toggles the selection state of all visible, enabled options.
            * Only applicable in multi-select mode.
            * @public
            */
           toggleSelectAll() {
                if (this.isDisabled || this.options.singleSelect === true) { // Explicit boolean check
                    return; // Only active in multi-select
                }

                if (!this.$customOptionsList || this.$customOptionsList.length === 0) {
                     console.warn(`[${this.containerId}] toggleSelectAll: Options list missing.`);
                     return;
                }

                // Operate only on visible, enabled options if search is active, otherwise all enabled options (use boolean value)
                const $optionItems = (this.options.enableSearch === true && this.$searchInput && this.$searchInput.length && this.$searchInput.val() !== '') // Explicit boolean check
                    ? this.$customOptionsList.find('li:visible:not(.disabled-option)')
                    : this.$customOptionsList.find('li:not(.disabled-option)');


                const totalOptions = $optionItems.length;
                if (totalOptions === 0) {
                     return;
                }

                const selectedOptionsCount = $optionItems.filter('.selected-option').length;
                const allCurrentlySelected = selectedOptionsCount === totalOptions;

                // Determine the new selection state for the options
                const selectAll = !allCurrentlySelected; // If all are currently selected, we want to deselect all, otherwise select all

                // Batch DOM updates for performance
                $optionItems.each(function() {
                    const $item = $(this);
                    if (selectAll) {
                        $item.addClass('selected-option').attr('aria-selected', 'true');
                    } else {
                        $item.removeClass('selected-option').attr('aria-selected', 'false');
                    }
                });

                // --- FIX: Update Select All button text based on the *new* state ---
                const newSelectedOptionsCount = $optionItems.filter('.selected-option').length;
                const allSelectedAfterToggle = totalOptions > 0 && newSelectedOptionsCount === totalOptions;
                this._updateSelectAllButton(allSelectedAfterToggle);
                // --- End FIX ---


                this.updateDisplay(); // Update the main display text
                this._triggerChangeEvent();

                // Keep focus on Select All button unless search is active, then focus search (use boolean value)
                if (this.options.enableSearch === true && this.$searchInput && this.$searchInput.length && this.$searchInput.val() !== '') { // Explicit boolean check
                    this.$searchInput.focus();
                } else if (this.$selectAllDiv && this.$selectAllDiv.length) {
                    this.$selectAllDiv.focus();
                }
           }

           /**
            * Enables the component, allowing user interaction.
            * @public
            */
           enable() {
               if (!this.isDisabled) {
                   return;
               }
               this.isDisabled = false;
               this.$container.removeClass('disabled');

               // Re-bind events when enabling
               this._bindEvents();

               if (this.$displayButton && this.$displayButton.length) {
                   this.$displayButton.prop('disabled', false).attr('tabindex', '0').removeClass('disabled-option');
               }
               // Only enable Select All if not single select
               if (this.options.singleSelect === false && this.$selectAllDiv && this.$selectAllDiv.length) {
                   this.$selectAllDiv.attr('aria-disabled', 'false').attr('tabindex', '0').show().removeClass('disabled-option');
               }
                if (this.$customOptionsList && this.$customOptionsList.length) {
                   this.$customOptionsList.find('li').each(function() {
                        $(this).removeClass('disabled-option').attr('aria-disabled', 'false').attr('tabindex', '-1');
                   });
                }
                // Enable search input if the option is set and show it
                if (this.options.enableSearch === true && this.$searchInput && this.$searchInput.length) {
                    this.$searchInput.prop('disabled', false).show();
                }

           }

           /**
            * Disables the component, preventing user interaction.
            * @public
            */
           disable() {
               if (this.isDisabled) {
                   return;
               }
               this.isDisabled = true;
               this.$container.addClass('disabled');

               this.hideSelect(); // Hide the dropdown if open

               // Unbind events when disabling
               this._unbindEvents();

               if (this.$displayButton && this.$displayButton.length) {
                   this.$displayButton.prop('disabled', true).attr('tabindex', '-1').addClass('disabled-option');
               }
               if (this.$selectAllDiv && this.$selectAllDiv.length) { // Always disable Select All when component is disabled
                   this.$selectAllDiv.attr('aria-disabled', 'true').attr('tabindex', '-1').addClass('disabled-option');
               }
                if (this.$customOptionsList && this.$customOptionsList.length) {
                   this.$customOptionsList.find('li').each(function() {
                        $(this).addClass('disabled-option').attr('aria-disabled', 'true').attr('tabindex', '-1');
                   });
                }
                // Disable search input and hide it
                if (this.options.enableSearch === true && this.$searchInput && this.$searchInput.length) {
                    this.$searchInput.prop('disabled', true).hide();
                }

           }

           /**
            * Gets the values of the currently selected options.
            * @public
            * @returns {Array<string>} An array of selected option values. Returns an empty array if no options are selected or the list is missing. In single-select mode, returns an array with at most one element.
            */
           getSelectedValues() {
                if (!this.$customOptionsList || this.$customOptionsList.length === 0) {
                     console.warn(`[${this.containerId}] getSelectedValues: Options list missing.`);
                     return [];
                }
                const $selectedItems = this.$customOptionsList.find('li.selected-option');
                return $selectedItems.map(function() {
                    return $(this).attr('data-value');
                }).get();
           }

           /**
            * Gets the text content of the currently selected options.
            * @public
            * @returns {Array<string>} An array of selected option text contents. Returns an empty array if no options are selected or the list is missing. In single-select mode, returns an array with at most one element.
            */
           getSelectedTexts() {
                if (!this.$customOptionsList || this.$customOptionsList.length === 0) {
                     console.warn(`[${this.containerId}] getSelectedTexts: Options list missing.`);
                     return [];
                }
                const $selectedItems = this.$customOptionsList.find('li.selected-option');
                return $selectedItems.map(function() {
                    // Optimized text extraction: cache text on load
                     const cachedText = $(this).data('original-text');
                     if (cachedText !== undefined) {
                         return cachedText;
                     } else {
                         const text = $(this).text().replace(/\s*笨能s*$/, '').trim();
                         $(this).data('original-text', text); // Cache the original text
                         return text;
                     }
                }).get();
           }

           /**
            * Sets the selected state for a single option item.
            * Extracted from setSelectedValues and setSelectedTexts.
            * @private
            * @param {jQuery} $item - The jQuery object of the option item.
            * @param {boolean} isSelected - True to select, false to deselect.
            */
           _setOptionSelectedState($item, isSelected) {
                if ($item && $item.length && !$item.hasClass('disabled-option')) {
                    if (isSelected) {
                        $item.addClass('selected-option').attr('aria-selected', 'true');
                    } else {
                        $item.removeClass('selected-option').attr('aria-selected', 'false');
                    }
                } else if ($item && $item.length && $item.hasClass('disabled-option')) {
                     console.warn(`[${this.containerId}] Attempted to change state of disabled option with value: ${$item.attr('data-value')}`);
                } else {
                     console.warn(`[${this.containerId}] _setOptionSelectedState: Invalid option item provided.`);
                }
           }

           /**
            * Sets the selected options based on an array of values.
            * Deselects all options first, then selects those matching the provided values.
            * Disabled options in the input array will not be selected.
            * In single-select mode, only the *last* value in the array will be selected.
            * @public
            * @param {Array<string>} values - An array of values to select.
            */
           setSelectedValues(values = []) {
                console.log(`[${this.containerId}] setSelectedValues called with values:`, values);
                if (!Array.isArray(values)) {
                    console.warn(`[${this.containerId}] setSelectedValues expects an array.`);
                    return;
                }
                if (!this.$customOptionsList || this.$customOptionsList.length === 0) {
                     console.warn(`[${this.containerId}] setSelectedValues: Options list missing.`);
                     return;
                }

                this._updateSelectionByList(values, true); // Call the new helper for setting selection
                this._performPostSelectionCleanup(); // Perform cleanup and update Select All button

                console.log(`[${this.containerId}] setSelectedValues complete.`);
           }

           /**
            * Sets the selected options based on an array of text contents.
            * Deselects all options first, then selects those matching the provided texts.
            * Disabled options matching the text will not be selected.
            * In single-select mode, only the *last* text in the array will be selected.
            * @public
            * @param {Array<string>} texts - An array of text contents to select.
            */
           setSelectedTexts(texts = []) {
                console.log(`[${this.containerId}] setSelectedTexts called with texts:`, texts);
                if (!Array.isArray(texts)) {
                    console.warn(`[${this.containerId}] setSelectedTexts expects an array.`);
                    return;
                }
                if (!this.$customOptionsList || this.$customOptionsList.length === 0) {
                     console.warn(`[${this.containerId}] setSelectedTexts: Options list missing.`);
                     return;
                }

                this._updateSelectionByList(texts, false); // Call the new helper for setting selection
                this._performPostSelectionCleanup(); // Perform cleanup and update Select All button

                console.log(`[${this.containerId}] setSelectedTexts complete.`);
           }

           /**
            * Creates a single list item element from option data.
            * Extracted from loadSelectOptions.
            * @private
            * @param {object} option - The option data object ({value, text, selected}).
            * @param {number} index - The index of the option in the data array.
            * @returns {jQuery|null} The created list item jQuery object, or null if data is invalid.
            */
           _createOptionListItem(option, index) {
               if (!option || typeof option !== 'object' || !option.hasOwnProperty('value') || !option.hasOwnProperty('text')) {
                   console.warn(`[${this.containerId}] _createOptionListItem: Skipping invalid option data at index ${index}:`, option);
                   return null;
               }

               const $newItem = $('<li></li>')
                   .attr('data-value', option.value)
                   .attr('tabindex', '-1')
                   .attr('role', 'option')
                   .attr('aria-selected', option.selected ? 'true' : 'false')
                   .text(option.text);

               const currentListSize = this.$customOptionsList.find('li').length;
               $newItem.attr('id', `${this.containerId}_option_${currentListSize + index}`);

               if (this.options.singleSelect === false) {
                    $newItem.prepend($('<span class="checkmark bi bi-check"></span>'));
                    $newItem.attr('data-option-type','multiple');
               }

               if (option.selected) {
                   $newItem.addClass('selected-option');
               }

               $newItem.data('original-text', option.text.trim());

               return $newItem;
           }


           /**
            * Loads options into the component dynamically.
            * Adds new ones from the provided data array.
            * If clearExisting is true, clears existing options first.
            * Stores the data if clearExisting is true for use with the refresh method.
            * @public
            * @param {Array<object>} optionsData - An array of option objects, each with 'value' and 'text' properties. Optional 'selected' property (boolean).
            * @param {boolean} [clearExisting=true] - Whether to clear existing options before adding new ones. Defaults to true.
            */
           loadSelectOptions(optionsData, clearExisting = true) {
                console.log(`[${this.containerId}] loadSelectOptions called with data:`, optionsData, `clearExisting: ${clearExisting}`);
                if (!Array.isArray(optionsData)) {
                    console.warn(`[${this.containerId}] loadSelectOptions expects an array for optionsData.`);
                    return;
                }
                if (!this.$customOptionsList || this.$customOptionsList.length === 0) {
                     console.warn(`[${this.containerId}] loadSelectOptions: Options list missing.`);
                     return;
                }

               if (clearExisting) {
                   this._initialOptionsData = [...optionsData];
                   this.$customOptionsList.empty();
                    console.log(`[${this.containerId}] Cleared existing options.`);
               }

               if (this.options.singleSelect === true && optionsData.some(opt => opt.selected)) {
                   this.$customOptionsList.find('li.selected-option').removeClass('selected-option').attr('aria-selected', 'false');
               }


               if (optionsData.length > 0) {
                    console.log(`[${this.containerId}] Adding ${optionsData.length} new options.`);
                   optionsData.forEach((option, index) => {
                       const $newItem = this._createOptionListItem(option, index);
                       if ($newItem) {
                           if (this.options.singleSelect === true && $newItem.hasClass('selected-option')) {
                                this.$customOptionsList.find('li.selected-option').not($newItem).removeClass('selected-option').attr('aria-selected', 'false');
                           }
                           this.$customOptionsList.append($newItem);
                       }
                   });
                    console.log(`[${this.containerId}] Finished adding options.`);
               } else {
                    console.log(`[${this.containerId}] No options data provided to add.`);
               }


                if (this.$searchInput && this.$searchInput.length) this.$searchInput.val('');
                if (this.$customOptionsList && this.$customOptionsList.length) this.$customOptionsList.find('li').show();
                this._updateActiveDescendant(null);
                if (this.$liveRegion && this.$liveRegion.length) this.$liveRegion.text('');

               this.updateDisplay();
               this._lastSelectedValues = this.getSelectedValues();
               this._triggerChangeEvent();
                console.log(`[${this.containerId}] loadSelectOptions complete.`);
           }

           /**
            * Applies the disabled state to internal elements when showing the component.
            * Extracted from showComponent.
            * @private
            */
           _applyDisabledStateOnShow() {
               this.$container.addClass('disabled');
               this._setElementDisabledState(this.$displayButton, true);
               this._setElementDisabledState(this.$selectAllDiv, true);
               if (this.$customOptionsList && this.$customOptionsList.length) {
                   this.$customOptionsList.find('li').each((index, element) => {
                       this._setElementDisabledState($(element), true);
                   });
               }
               this._setElementDisabledState(this.$searchInput, true);
           }

           /**
            * Applies the enabled state to internal elements when showing the component.
            * Extracted from showComponent.
            * @private
            */
           _applyEnabledStateOnShow() {
               this._setElementDisabledState(this.$displayButton, false);
               // Only enable Select All if not single select
               if (this.options.singleSelect === false) {
                   this._setElementDisabledState(this.$selectAllDiv, false);
                   if (this.$selectAllDiv && this.$selectAllDiv.length) this.$selectAllDiv.show(); // Ensure visible
               }
               if (this.$customOptionsList && this.$customOptionsList.length) {
                   this.$customOptionsList.find('li').each((index, element) => {
                       this._setElementDisabledState($(element), false);
                   });
               }
               // Enable search input if the option is set and show it
               if (this.options.enableSearch === true) {
                   this._setElementDisabledState(this.$searchInput, false);
                   if (this.$searchInput && this.$searchInput.length) this.$searchInput.show();
               }
           }


           /**
            * Shows the entire component.
            * @public
            */
           showComponent() {
                console.log(`[${this.containerId}] showComponent called.`);
                if (this.isDisabled) {
                    return;
                }
                if (!this.$container || this.$container.length === 0) {
                     console.warn(`[${this.containerId}] showComponent: Container element missing.`);
                     return;
                }

                this.$container.removeClass('hidden-component');
                this._bindEvents();
                if (this.$displayButton && this.$displayButton.length) {
                    this.$displayButton.attr('tabindex', '0');
                }

                if (this.isDisabled) {
                    this._applyDisabledStateOnShow();
                } else {
                    this._applyEnabledStateOnShow();
                }

                console.log(`[${this.containerId}] Component shown.`);
           }

           /**
            * Hides the entire component.
            * @public
            */
           hideComponent() {
                console.log(`[${this.containerId}] hideComponent called.`);
                if (this.$container && this.$container.length) {
                    this.hideSelect();
                    this.$container.addClass('hidden-component');
                    this._unbindEvents();
                    if (this.$displayButton && this.$displayButton.length) {
                        this.$displayButton.attr('tabindex', '-1');
                    }
                    console.log(`[${this.containerId}] Component hidden.`);
                } else {
                     console.warn(`[${this.containerId}] hideComponent: Container element missing.`);
                }
           }

           /**
            * Resets the component to its initial state: enabled, visible,
            * with selection cleared, and reloads the initial options data.
            * @public
            */
           refresh() {
                console.log(`[${this.containerId}] Refreshing component...`);

                this.enable();
                this.showComponent();

                this.setSelectedValues([]);

                if (this._initialOptionsData && Array.isArray(this._initialOptionsData) && this._initialOptionsData.length > 0) {
                     this.loadSelectOptions(this._initialOptionsData, true);
                } else {
                     if (this.$customOptionsList && this.$customOptionsList.length) {
                          this.$customOptionsList.empty();
                     }
                     this.updateDisplay();
                     this._lastSelectedValues = [];
                     this._triggerChangeEvent();
                }

                if (this.$searchInput && this.$searchInput.length) {
                     this.$searchInput.val('');
                }
                if (this.$customOptionsList && this.$customOptionsList.length) {
                     this.$customOptionsList.find('li').show();
                }

                this._updateActiveDescendant(null);
                if (this.$liveRegion && this.$liveRegion.length) {
                     this.$liveRegion.text('');
                }

                console.log(`[${this.containerId}] Component refreshed.`);
           }

           /**
            * Sets the disabled state and related attributes for a given element.
            * Extracted from enable and disable.
            * @private
            * @param {jQuery} $element - The jQuery element to set state for.
            * @param {boolean} isDisabled - True to disable, false to enable.
            */
           _setElementDisabledState($element, isDisabled) {
               if ($element && $element.length) {
                   $element.prop('disabled', isDisabled).attr('aria-disabled', isDisabled ? 'true' : 'false');
                   if (isDisabled) {
                       $element.attr('tabindex', '-1').addClass('disabled-option');
                   } else {
                       // Only set tabindex to 0 if it's a naturally focusable element or explicitly needs focus
                       // For list items, tabindex is managed by keyboard navigation handlers
                       if ($element.is('button, input, [role="button"]')) {
                            $element.attr('tabindex', '0');
                       } else {
                             $element.attr('tabindex', '-1');
                       }
                       $element.removeClass('disabled-option');
                   }
               }
           }


           /**
            * Destroys the component instance, unbinds events, and removes elements if necessary.
            * Useful for cleanup, especially in dynamic contexts like DataTables rows.
            * @public
            */
           destroy() {
                console.log(`[${this.containerId}] Destroying component instance.`);

                if (this.$dropdownContainer && this.$dropdownContainer.length && this.$dropdownContainer.is(':visible') && !$.contains(this.$container[0], this.$dropdownContainer[0])) {
                     this.$dropdownContainer.remove();
                     console.log(`[${this.containerId}] Removed detached dropdown from body during destroy.`);
                } else if (this.$dropdownContainer && this.$dropdownContainer.length) {
                    this.$dropdownContainer.hide();
                }


                this._unbindEvents();
                console.log(`[${this.containerId}] Events unbound during destroy.`);

                if (this.$container && this.$container.length) {
                    this.$container.removeData('customMultiSelect');
                    console.log(`[${this.containerId}] Removed instance data.`);
                }

                 this.$container = null;
                 this.$labelElement = null;
                 this.$displayButton = null;
                 this.$selectedTextSpan = null;
                 this.$dropdownContainer = null;
                 this.$selectAllDiv = null;
                 this.$customOptionsList = null;
                 this.$searchInput = null;
                 this.$liveRegion = null;
                 this._originalDropdownParent = null;
                 this._initialOptionsData = null;
                 this._lastSelectedValues = null;

                console.log(`[${this.containerId}] Component destroyed.`);
           }

            /**
             * Handles the setter logic for the overridden $.fn.val method.
             * @private
             * @param {*} value - The value(s) to set.
             */
            _handleValSetter(value) {
                if (this.options.singleSelect === true) {
                    this.setSelectedValues(value === null || typeof value === 'undefined' ? [] : [value]);
                } else {
                    this.setSelectedValues(Array.isArray(value) ? value : []);
                }
            }

            /**
             * Handles the getter logic for the overridden $.fn.val method.
             * @private
             * @returns {*} The selected value(s).
             */
            _handleValGetter() {
                if (this.options.singleSelect === true) {
                    const selectedValues = this.getSelectedValues();
                    return selectedValues.length > 0 ? selectedValues[0] : null;
                } else {
                    return this.getSelectedValues();
                }
            }
       }

       const originalValMethod = $.fn.val;
       console.log("Saved reference to original $.fn.val:", originalValMethod);


       $.fn.val = function(value) {
           const $firstElement = this.first();
           const instance = $firstElement.data('customMultiSelect');

           if (instance) {
               if (this.length > 0 && arguments.length > 0) {
                   // Setter
                   instance._handleValSetter(value);
                   return this;
               } else {
                   // Getter
                   return instance._handleValGetter();
               }
           } else {
               return originalValMethod.apply(this, arguments);
           }
       };
       console.log("Overridden $.fn.val defined.");


       $.fn.customMultiSelect = function(options) {
           const originalArguments = arguments;


           return this.each(function() {
               const $container = $(this);
               let instance = $container.data('customMultiSelect');

               if (typeof options === 'string') {
                   const methodName = options;
                   const methodArgs = Array.prototype.slice.call(originalArguments, 1);

                    if (!instance) {
                        console.error(`Plugin: Attempted to call method "${methodName}" on an uninitialized element:`, this);
                        return;
                    }

                   if (typeof instance[methodName] === 'function' && !methodName.startsWith('_')) {
                        instance[methodName](...methodArgs); // Refactored: Using spread operator
                   } else {
                       console.error(`Plugin: Method "${methodName}" does not exist or is private on CustomMultiSelect instance for element:`, this);
                   }
               } else if (!instance) { // Refactored: combined else and nested if check
                     // If options is an object or undefined, it's an initialization call
                     instance = new CustomMultiSelect($container, options);
                     $container.data('customMultiSelect', instance);
                 } else {
                     // Element already initialized, skipping.
                 }
           });
       };

$(document).ready(function () {
    $('.custom-multi-select').customMultiSelect();


    $('label[for$="_display"]').on('click', function (event) {
        event.preventDefault();

        const targetId = $(this).attr('for');
        const $targetElement = $('#' + targetId);

        if ($targetElement.length) {
            $targetElement.focus();
        } else {
            console.warn(`Element with ID "${targetId}" not found for label.`);
        }
    });
});
